<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/two.js"></script>
    <script src="js/projection.js"></script>
    <link rel="stylesheet" href="css/projection.css">
</head>
<body>

<div id="projection-xy" class="projection xy"></div>
Projection X-Y (Z constant). Valeur de Z : <input type="number" id="projection-xy-constant-value">


<div id="projection-xz" class="projection xz"></div>
Projection X-Z (Y constant). Valeur de Y : <input type="number" id="projection-xz-constant-value">


<div id="projection-yz" class="projection yz"></div>
Projection Y-Z (X constant). Valeur de X : <input type="number" id="projection-yz-constant-value">


<script>
    var p = new HandleProjection('projection-xz');

    var two = new Two({
        type: Two.Types.svg,
        fullscreen: false,
        autostart: true,
        width: '400px',
        height: '200px',
    }).appendTo(document.getElementById("projection-xy"));

    // The cursor, matched with your mouse
    var mouse = new Two.Vector();
    mouse.radius = 4;
    mouse.radiusSquared = Math.pow(mouse.radius, 2);
    mouse.dragging = false;
    mouse.intersection = null;
    mouse.selected = new Two.Circle(0, 0, 2);
    mouse.selected.stroke = '#00AEFF';
    mouse.selected.scale = 2;
    mouse.selected.visible = false;

    var content = two.makeGroup(); // Everything that is drawn black
    var interaction = two.makeGroup();  // All the blue interactive elements

    // The blue path highlight
    var selection = new Two.Path();
    selection.stroke = '#00AEFF';
    selection.noFill();
    selection.automatic = false;
    selection.visible = false;

    interaction.add(selection);

    // A list of all the editable anchor points
    var points = new Two.Points();
    points.size = 4;
    points.stroke = '#00AEFF';
    interaction.add(points, mouse.selected);

    var path; // Used to reference the currently selected path
    var domElement = two.renderer.domElement;

    domElement.addEventListener('mousedown', mousedown, false);
    domElement.addEventListener('dblclick', doubleclick, false);
    domElement.addEventListener('mousemove', mousemove, false);

    function create() {

        path = new Two.Path();
        path.linewidth = 2;
        path.noFill();
        path.automatic = false;

        points.vertices = path.vertices;
        selection.vertices = path.vertices;

        content.add(path);

    }

    function add(x, y) {

        var anchor = new Two.Anchor(x, y, 0, 0, 0, 0);
        anchor.command = Two.Commands[path.vertices.length > 0 ? 'curve' : 'move'];

        path.vertices.push(anchor);

        return anchor;

    }

    function remove(i) {

        mouse.selected.visible = false;
        path.vertices.splice(i, 1);

    }

    function close(x, y) {
        path.closed = true;
        deselect();

        path = null;

    }

    function select() {

        points.visible = true;
        selection.visible = true;

    }

    function deselect() {

        points.visible = false;
        selection.visible = false;

    }


    /**
     * Browser interactions handle below
     */

    function mousedown(e) {

        if (mouse.intersection) {
            mouse.dragging = true;
            if (mouse.intersection.id === 0) {
                // Hack to emulate closing, but actually using
                // one last point to simulate the left control handle
                // of the first point.
                var spoof = path.vertices[0];
                add(spoof.x, spoof.y);
            }
        } else {
            if (!path) {
                create();
                add(e.clientX, e.clientY);
                select();
            } else {
                add(e.clientX, e.clientY);
            }
        }

        window.addEventListener('mouseup', mouseup, false);

    }

    function doubleclick() {

        if (!path) {
            return;
        }

        var first = path.vertices[0];

        var last = add(first.x, first.y);


        close();

    }

    function mousemove(e) {

        // Calculate what object is intersecting the mouse
        // only when we're not already doing some other interaction

        if (mouse.dragging) {
            return;
        }

        var x = mouse.x;
        var y = mouse.y;

        mouse.set(e.clientX, e.clientY);

        mouse.intersection = null;

        for (var i = 0; i < points.vertices.length; i++) {

            var point = points.vertices[i];
            var d = point.distanceToSquared(mouse);

            if (d <= mouse.radiusSquared) {
                mouse.selected.visible = true;
                mouse.selected.position.copy(point);
                mouse.intersection = {
                    object: mouse.selected,
                    id: i
                };
            }

        }

        if (!mouse.intersection) {
            mouse.selected.visible = false;
        }

    }


    function mouseup() {

        if (mouse.intersection) {

            if (mouse.dragging === true) {

                // Close or remove a point from a path

                if (mouse.intersection.id > 0) {

                    remove(mouse.intersection.id);

                } else {
                    close();
                }

            }

        }
        // Reset listeners and context aware variables.
        window.removeEventListener('mouseup', mouseup, false);

        mouse.dragging = false;
        mouse.intersection = null;

        selection.closed = false;

    }</script>
</body>
</html>